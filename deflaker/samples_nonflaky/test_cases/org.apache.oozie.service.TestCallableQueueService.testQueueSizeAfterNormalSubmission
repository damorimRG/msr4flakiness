public void testQueueSizeAfterNormalSubmission() throws InterruptedException {
    final int taskCount = 10_000;
    List<DummyCallable> callables = new ArrayList<>(taskCount);
    for (int i = 0; i < taskCount; i++) {
        String keyAndType = String.valueOf(i);
        DummyCallable dc = new DummyCallable(taskCount, keyAndType, keyAndType, 0, 0);
        callables.add(dc);
    }
    CallableQueueService queueservice = Services.get().get(CallableQueueService.class);
    for (int i = 0; i < taskCount; i++) {
        queueservice.queue(callables.get(i));
    }
    // Not an exact number - it's close to 10,000 but keeps fluctuating
    // We can still verify that it's larger than a certain number though
    int queueSizeAfterSubmission = queueservice.queueSize();
    try {
        finished.await(10, TimeUnit.SECONDS);
    } catch (Exception e) {
        log.error("Error", e);
        fail("Exception during test: " + e.getMessage());
    }
    // It's necessary because after finished.await() returns, the last XCallable
    // could still be running
    waitFor(1000, new Predicate() {

        @Override
        public boolean evaluate() throws Exception {
            return queueservice.queueSize() == 0;
        }
    });
    assertTrue("Too few elements in the queue: " + queueSizeAfterSubmission + ", should be >9000", queueSizeAfterSubmission > 9000);
    assertEquals("Queue size after execution", 0, queueservice.queueSize());
}
