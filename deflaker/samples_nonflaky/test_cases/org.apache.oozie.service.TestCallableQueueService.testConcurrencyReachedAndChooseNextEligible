/**
 * When using config 'oozie.service.CallableQueueService.callable.next.eligible' true, the next other type of callables
 * should be invoked when top one in the queue is reached max concurrency.
 *
 * @throws Exception
 */
public void testConcurrencyReachedAndChooseNextEligible() throws Exception {
    Services.get().destroy();
    setSystemProperty(CallableQueueService.CONF_CALLABLE_NEXT_ELIGIBLE, "true");
    new Services().init();
    CLCallable.resetConcurrency();
    final CallableQueueService queueservice = Services.get().get(CallableQueueService.class);
    final MyCallable callable1 = new MyCallable(0, 100);
    final MyCallable callable2 = new MyCallable(0, 100);
    final MyCallable callable3 = new MyCallable(0, 100);
    final MyCallable callable4 = new MyCallable(0, 100);
    final MyCallable callable5 = new MyCallable(0, 100);
    final MyCallable callable6 = new MyCallable(0, 100);
    List<MyCallable> callables = Arrays.asList(callable1, callable2, callable3, callable4, callable5, callable6);
    final MyCallable callableOther = new MyCallable("other", 0, 100);
    long now = System.currentTimeMillis();
    queueservice.queue(callableOther, 15);
    for (MyCallable c : callables) {
        queueservice.queue(c, 10);
    }
    waitFor(3000, new Predicate() {

        public boolean evaluate() throws Exception {
            boolean completed = true;
            for (MyCallable callable : callables) {
                completed &= (callable.executed != 0);
            }
            completed &= (callableOther.executed != 0);
            return completed;
        }
    });
    long last = Long.MIN_VALUE;
    for (MyCallable c : callables) {
        System.out.println("Callable C executed :" + c.executed);
        assertTrue(c.executed != 0);
        last = Math.max(last, c.executed);
    }
    System.out.println("Callable callableOther executed :" + callableOther.executed);
    assertTrue(callableOther.executed < last);
    assertTrue(callableOther.executed > (now + 115));
}
