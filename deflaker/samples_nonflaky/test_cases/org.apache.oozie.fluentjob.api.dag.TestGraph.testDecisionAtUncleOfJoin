@Test
public void testDecisionAtUncleOfJoin() {
    final String conditionGotoD = "condition_goto_D";
    final String conditionGotoF = "condition_goto_F";
    final Node a = MapReduceActionBuilder.create().withName("A").build();
    final Node b = MapReduceActionBuilder.create().withName("B").withParent(a).build();
    final Node c = MapReduceActionBuilder.create().withName("C").withParent(a).build();
    final Node d = MapReduceActionBuilder.create().withName("D").withParentWithCondition(c, conditionGotoD).build();
    final Node e = MapReduceActionBuilder.create().withName("E").withParent(b).withParent(d).build();
    final Node f = MapReduceActionBuilder.create().withName("F").withParentWithCondition(c, conditionGotoF).build();
    MapReduceActionBuilder.create().withName("G").withParent(e).build();
    MapReduceActionBuilder.create().withName("H").withParent(f).build();
    final Workflow workflow = new WorkflowBuilder().withName("decision-at-uncle-of-join").withDagContainingNode(a).build();
    final Graph graph = new Graph(workflow);
    final NodeBase A = new ExplicitNode("A", null);
    final NodeBase B = new ExplicitNode("B", null);
    final NodeBase C = new ExplicitNode("C", null);
    final NodeBase D = new ExplicitNode("D", null);
    final NodeBase E = new ExplicitNode("E", null);
    final NodeBase F = new ExplicitNode("F", null);
    final NodeBase G = new ExplicitNode("G", null);
    final NodeBase H = new ExplicitNode("H", null);
    final Start start = new Start("start");
    final End end = new End("end");
    final Fork fork = new Fork("fork1");
    final Join join = new Join("join1", fork);
    final Decision decision = new Decision("decision1");
    final DecisionJoin decisionJoin = new DecisionJoin("decisionJoin1", decision);
    end.addParent(decisionJoin);
    decisionJoin.addParent(G);
    decisionJoin.addParent(H);
    G.addParent(E);
    H.addParent(F);
    E.addParent(D);
    D.addParentWithCondition(decision, Condition.actualCondition(conditionGotoD));
    F.addParentWithCondition(decision, Condition.actualCondition(conditionGotoF));
    decision.addParent(join);
    join.addParent(B);
    join.addParent(C);
    B.addParent(fork);
    C.addParent(fork);
    fork.addParent(A);
    A.addParent(start);
    final List<NodeBase> nodes = Arrays.asList(start, end, fork, join, decision, decisionJoin, A, B, C, D, E, F, G, H);
    // nodesToPng.withWorkflow(workflow);
    // nodesToPng.withGraph(graph);
    checkEqualStructureByNames(nodes, graph);
}
