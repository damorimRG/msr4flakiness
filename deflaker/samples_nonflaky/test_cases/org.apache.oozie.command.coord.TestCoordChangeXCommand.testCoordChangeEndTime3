/**
 * Testcase when changing end-time to after original end-time
 * but before nextMaterializedTime should not cause unnecessary changes
 *
 * @throws Exception
 */
public void testCoordChangeEndTime3() throws Exception {
    JPAService jpaService = Services.get().get(JPAService.class);
    Date startTime = new Date();
    Date endTime = new Date(startTime.getTime() + (10 * 60 * 1000));
    CoordinatorJobBean coordJob = addRecordToCoordJobTable(CoordinatorJob.Status.RUNNING, startTime, endTime, true, true, 1);
    coordJob.setNextMaterializedTime(new Date(startTime.getTime() + (40 * 60 * 1000)));
    CoordJobQueryExecutor.getInstance().executeUpdate(CoordJobQuery.UPDATE_COORD_JOB, coordJob);
    addRecordToCoordActionTable(coordJob.getId(), 1, CoordinatorAction.Status.SUCCEEDED, "coord-action-get.xml", 0);
    Runnable runnable = new StatusTransitService.StatusTransitRunnable();
    runnable.run();
    CoordJobGetJPAExecutor coordGetCmd = new CoordJobGetJPAExecutor(coordJob.getId());
    coordJob = jpaService.execute(coordGetCmd);
    assertEquals(Job.Status.SUCCEEDED, coordJob.getStatus());
    assertFalse(coordJob.isPending());
    assertTrue(coordJob.isDoneMaterialization());
    String newEndTime = convertDateToString(startTime.getTime() + 20 * 60 * 1000);
    try {
        new CoordChangeXCommand(coordJob.getId(), "endtime=" + newEndTime).call();
    } catch (Exception e) {
        assertTrue(e.getMessage().contains("Didn't change endtime. Endtime is in between coord end time and next materialization time"));
    }
    coordJob = jpaService.execute(coordGetCmd);
    assertFalse(Job.Status.RUNNING == coordJob.getStatus());
    assertFalse(coordJob.isPending());
    assertTrue(coordJob.isDoneMaterialization());
}
