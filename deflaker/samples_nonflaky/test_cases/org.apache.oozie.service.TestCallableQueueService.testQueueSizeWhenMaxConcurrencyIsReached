public void testQueueSizeWhenMaxConcurrencyIsReached() throws InterruptedException {
    int partitions = 10;
    int taskPerPartition = 1000;
    final int taskCount = partitions * taskPerPartition;
    List<DummyCallable> callables = new ArrayList<>(taskCount);
    for (int i = 0; i < partitions; i++) {
        String type = String.valueOf(i);
        for (int j = 0; j < taskPerPartition; j++) {
            String key = type + "_" + UUID.randomUUID().toString();
            DummyCallable dc = new DummyCallable(taskCount, key, type, 0, 0);
            callables.add(dc);
        }
    }
    CallableQueueService queueservice = Services.get().get(CallableQueueService.class);
    for (int i = 0; i < taskCount; i++) {
        queueservice.queue(callables.get(i));
    }
    // Not an exact number - it's close to 10,000 but keeps fluctuating
    // We can still verify that it's larger than a certain number though
    int queueSizeAfterSubmission = queueservice.queueSize();
    try {
        finished.await(10, TimeUnit.SECONDS);
    } catch (Exception e) {
        log.error("Error", e);
        fail("Exception during test: " + e.getMessage());
    }
    // It's necessary because after finished.await() returns, the last XCallable
    // could still be running
    waitFor(1000, new Predicate() {

        @Override
        public boolean evaluate() throws Exception {
            return queueservice.queueSize() == 0;
        }
    });
    assertTrue("Too few elements in the queue: " + queueSizeAfterSubmission + ", should be >9000", queueSizeAfterSubmission > 9000);
    assertEquals("Queue size after execution", 0, queueservice.queueSize());
}
