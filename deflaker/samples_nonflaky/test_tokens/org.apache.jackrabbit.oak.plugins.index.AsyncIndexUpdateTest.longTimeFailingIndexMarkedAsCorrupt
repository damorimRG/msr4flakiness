fooIndex
 7. Lets reindex barIndex and ensure index is not misbehaving
 Indexing would be considered as failing
 lookup should also fail as indexing failed
run
waitUntil
getStatus
 6. Index some stuff
pqr
bar
ImmutableSet
 fooIndex should now report updated result. barIndex would fail
find
ASYNC_PROPERTY_NAME
merge
xyz
 3. Now fail the indexing for 'bar'
setClock
 fooIndex is fine
 2. Add some new content
getFailingIndexData
reindex
INDEX_DEFINITIONS_NAME
containsKey
getCorruptIntervalMillis
 barIndex should be skipped
clock
 merge it back in
enableFailureMode
setProperty
longTimeFailingIndexMarkedAsCorrupt
EmptyHook
disableFailureMode
child
getIndexStats
getCorruptIndexHandler
 now barIndex should not be part of failing index
getTime
foo
createIndexDefinition
assertFalse
getCorruptIndexData
testRoot6
testRoot5
barIndex
 1. Basic sanity check. Indexing works
testRoot4
 5. Let async run again
provider
assertTrue
 barIndex is failing but not yet considered corrupted
of
isFailing
get
IndexStatsMBean
builder
CommitInfo
/oak:index/fooIndex
getRoot
oak:index
 barIndex should be considered corrupt now
lookup
abc
barIndexInfo
isEmpty
/oak:index/barIndex
assertEquals
store
testRoot3
async
testRoot2
testRoot1
getSkippedCount
 4.Now move the clock forward and let the failing index marked as corrupt
